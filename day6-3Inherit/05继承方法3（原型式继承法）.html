<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>05继承方法3（原型式继承法）</title>
	<script>
		/*
			
			组合继承法：
				* 缺点（原型链继承法的缺点）：
					* 在原型对象中生成多余的属性
					* 多次执行父类构造函数


			原型式继承法
				* 核心：先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时构造函数的一个新实例


			最终继承解决方案（完美方案）：寄生组合继承法
				* 继承属性:借用构造函数
				* 继承方法：原型式继承法
		 */
		
		function Person(name,age,gender){
			// 属性
			this.name = name;
			this.age = age;
			this.gender = gender;
		}


		Person.prototype = {
			say(){
				console.log('say')
			},
			sleep(){
				console.log('sleep')
			},
			sport(){
				console.log('sport')
			},
			coding(){
				console.log('coding')
			}
		}


		// 子类
		function Man(name,age){
			Person.call(this,name,age,'男');
		}

		// 原型链继承法：拿父类实例来充当子类原型对象
		// Man.prototype = new Person();

		// 原型式继承法：
		// Man.prototype = inherit(Person.prototype);
		// function inherit(o){
		// 	// 创建临时构造函数F
	 //        function F(){}

	 //        // 将传入的对象作为这个构造函数的原型
	 //        F.prototype = o;

	 //        // 返回临时否则函数的实例
	 //        return new F();
	 //    }

	 	// ES5静态方法：
		Man.prototype = Object.create(Person.prototype);

		Man.prototype.constructor = Man;


	    let m = new Man('tiantian',28);





	</script>
</head>
<body>
	<h1>05继承方法3（原型式继承法）</h1>
</body>
</html>
</html>